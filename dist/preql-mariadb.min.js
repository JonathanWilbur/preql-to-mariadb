var preqlmariadb=function(e){var r={};function n(t){if(r[t])return r[t].exports;var a=r[t]={i:t,l:!1,exports:{}};return e[t].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=r,n.d=function(e,r,t){n.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,r){if(1&r&&(e=n(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var a in e)n.d(t,a,function(r){return e[r]}.bind(null,a));return t},n.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(r,"a",r),r},n.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},n.p="",n(n.s=0)}({"./source/Commands/transpile.ts":
/*!**************************************!*\
  !*** ./source/Commands/transpile.ts ***!
  \**************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { "default": mod };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst attribute_1 = __importDefault(__webpack_require__(/*! ../Transpilers/attribute */ "./source/Transpilers/attribute.ts"));\r\nconst database_1 = __importDefault(__webpack_require__(/*! ../Transpilers/database */ "./source/Transpilers/database.ts"));\r\nconst entry_1 = __importDefault(__webpack_require__(/*! ../Transpilers/entry */ "./source/Transpilers/entry.ts"));\r\nconst foreignkey_1 = __importDefault(__webpack_require__(/*! ../Transpilers/foreignkey */ "./source/Transpilers/foreignkey.ts"));\r\nconst plainindex_1 = __importDefault(__webpack_require__(/*! ../Transpilers/plainindex */ "./source/Transpilers/plainindex.ts"));\r\nconst postamble_1 = __importDefault(__webpack_require__(/*! ../Transpilers/postamble */ "./source/Transpilers/postamble.ts"));\r\nconst preamble_1 = __importDefault(__webpack_require__(/*! ../Transpilers/preamble */ "./source/Transpilers/preamble.ts"));\r\nconst spatialindex_1 = __importDefault(__webpack_require__(/*! ../Transpilers/spatialindex */ "./source/Transpilers/spatialindex.ts"));\r\nconst struct_1 = __importDefault(__webpack_require__(/*! ../Transpilers/struct */ "./source/Transpilers/struct.ts"));\r\nconst textindex_1 = __importDefault(__webpack_require__(/*! ../Transpilers/textindex */ "./source/Transpilers/textindex.ts"));\r\nconst uniqueindex_1 = __importDefault(__webpack_require__(/*! ../Transpilers/uniqueindex */ "./source/Transpilers/uniqueindex.ts"));\r\nconst server_1 = __importDefault(__webpack_require__(/*! ../Transpilers/server */ "./source/Transpilers/server.ts"));\r\n// This will break once you upgrade to a higher version of MariaDB.\r\n// See: https://dataedo.com/kb/query/mariadb/list-check-constraints-in-database\r\n// https://stackoverflow.com/questions/12637945/how-can-i-delete-all-the-triggers-in-a-mysql-database-using-one-sql-statement\r\nconst dropAllPreqlCheckConstraintsForTableTemplate = (db) => {\r\n    const schemaName = db.spec.name;\r\n    const spName = `${schemaName}.dropAllPreqlCheckConstraintsForTable`;\r\n    return [\r\n        `DROP PROCEDURE IF EXISTS ${spName}`,\r\n        `CREATE PROCEDURE ${spName} (IN param_table VARCHAR(255))\\r\\n`\r\n            + "BEGIN\\r\\n"\r\n            + "\\tDECLARE done BOOLEAN DEFAULT FALSE;\\r\\n"\r\n            + "\\tDECLARE dropCommand VARCHAR(255);\\r\\n"\r\n            + "\\tDECLARE dropCur CURSOR FOR\\r\\n"\r\n            + `\\t\\tSELECT concat(\'ALTER TABLE ${schemaName}.\', table_name, \' DROP CONSTRAINT \', constraint_name, \';\')\\r\\n`\r\n            + "\\t\\tFROM information_schema.table_constraints\\r\\n"\r\n            + "\\t\\tWHERE\\r\\n"\r\n            + "\\t\\t\\tconstraint_type = \'CHECK\'\\r\\n"\r\n            + "\\t\\t\\tAND constraint_name LIKE \'preql_\'\\r\\n"\r\n            + `\\t\\t\\tAND table_schema = \'${schemaName}\'\\r\\n`\r\n            + "\\t\\t\\tAND table_name = param_table;\\r\\n"\r\n            + "\\tDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\\r\\n"\r\n            + "\\tOPEN dropCur;\\r\\n"\r\n            + "\\tread_loop: LOOP\\r\\n"\r\n            + "\\t\\tFETCH dropCur\\r\\n"\r\n            + "\\t\\tINTO dropCommand;\\r\\n"\r\n            + "\\t\\tIF done THEN\\r\\n"\r\n            + "\\t\\t\\tLEAVE read_loop;\\r\\n"\r\n            + "\\t\\tEND IF;\\r\\n"\r\n            + "\\t\\tSET @sdropCommand = dropCommand;\\r\\n"\r\n            + "\\t\\tPREPARE dropClientUpdateKeyStmt FROM @sdropCommand;\\r\\n"\r\n            + "\\t\\tEXECUTE dropClientUpdateKeyStmt;\\r\\n"\r\n            + "\\t\\tDEALLOCATE PREPARE dropClientUpdateKeyStmt;\\r\\n"\r\n            + "\\tEND LOOP;\\r\\n"\r\n            + "\\tCLOSE dropCur;\\r\\n"\r\n            + "END",\r\n    ];\r\n};\r\nconst callDropAllPreqlCheckConstraintsForTableTemplate = (struct) => [\r\n    `CALL ${struct.spec.databaseName}.dropAllPreqlCheckConstraintsForTable(\'${struct.spec.name}\')`,\r\n];\r\nconst transpile = async (etcd, logger) => {\r\n    let transpilations = [];\r\n    const preambles = etcd.kindIndex.preamble;\r\n    if (preambles && preambles.length > 0) {\r\n        await Promise.all(preambles.map(async (obj) => {\r\n            const statements = await preamble_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const servers = etcd.kindIndex.server;\r\n    if (servers && servers.length > 0) {\r\n        await Promise.all(servers.map(async (obj) => {\r\n            const statements = await server_1.default(obj, logger, etcd);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const databases = etcd.kindIndex.database;\r\n    if (databases && databases.length > 0) {\r\n        await Promise.all(databases.map(async (obj) => {\r\n            const statements = await database_1.default(obj, logger, etcd);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n        await Promise.all(databases.map(async (obj) => {\r\n            const statements = dropAllPreqlCheckConstraintsForTableTemplate(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const structs = etcd.kindIndex.struct;\r\n    if (structs && structs.length > 0) {\r\n        await Promise.all(structs.map(async (obj) => {\r\n            const statements = await struct_1.default(obj, logger, etcd);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n        await Promise.all(structs.map(async (obj) => {\r\n            const statements = callDropAllPreqlCheckConstraintsForTableTemplate(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const attributes = etcd.kindIndex.attribute;\r\n    if (attributes && attributes.length > 0) {\r\n        await Promise.all(attributes.map(async (obj) => {\r\n            const statements = await attribute_1.default(obj, logger, etcd);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const plainindexes = etcd.kindIndex.plainindex;\r\n    if (plainindexes && plainindexes.length > 0) {\r\n        await Promise.all(plainindexes.map(async (obj) => {\r\n            const statements = await plainindex_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const uniqueindexes = etcd.kindIndex.uniqueindex;\r\n    if (uniqueindexes && uniqueindexes.length > 0) {\r\n        await Promise.all(uniqueindexes.map(async (obj) => {\r\n            const statements = await uniqueindex_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const textindexes = etcd.kindIndex.textindex;\r\n    if (textindexes && textindexes.length > 0) {\r\n        await Promise.all(textindexes.map(async (obj) => {\r\n            const statements = await textindex_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const spatialindexes = etcd.kindIndex.spatialindex;\r\n    if (spatialindexes && spatialindexes.length > 0) {\r\n        await Promise.all(spatialindexes.map(async (obj) => {\r\n            const statements = await spatialindex_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const foreignKeys = etcd.kindIndex.foreignkey;\r\n    if (foreignKeys && foreignKeys.length > 0) {\r\n        await Promise.all(foreignKeys.map(async (obj) => {\r\n            const statements = await foreignkey_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const entries = etcd.kindIndex.entry;\r\n    if (entries && entries.length > 0) {\r\n        await Promise.all(entries.map(async (obj) => {\r\n            const statements = await entry_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    const postambles = etcd.kindIndex.postamble;\r\n    if (postambles && postambles.length !== 0) {\r\n        await Promise.all(postambles.map(async (obj) => {\r\n            const statements = await postamble_1.default(obj);\r\n            transpilations = transpilations.concat(statements);\r\n        }));\r\n    }\r\n    return transpilations.filter((t) => (t.trim() !== ""));\r\n};\r\nexports.default = transpile;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Commands/transpile.ts?')},"./source/ConsoleLogger.ts":
/*!*********************************!*\
  !*** ./source/ConsoleLogger.ts ***!
  \*********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nclass ConsoleLogger {\r\n    debug(event) {\r\n        if (console)\r\n            console.debug(event);\r\n    }\r\n    info(event) {\r\n        if (console)\r\n            console.info(event);\r\n    }\r\n    warn(event) {\r\n        if (console)\r\n            console.warn(event);\r\n    }\r\n    error(event) {\r\n        if (console)\r\n            console.error(event);\r\n    }\r\n}\r\nexports.default = ConsoleLogger;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/ConsoleLogger.ts?')},"./source/Transpilers/attribute.ts":
/*!*****************************************!*\
  !*** ./source/Transpilers/attribute.ts ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst transpileAttribute = async (obj, logger, etcd) => {\r\n    const tableName = obj.spec.multiValued\r\n        ? `${obj.spec.structName}_${obj.spec.name}`\r\n        : obj.spec.structName;\r\n    let ret = [];\r\n    if (obj.spec.multiValued) {\r\n        ret.push(`CREATE TABLE IF NOT EXISTS ${obj.spec.databaseName}.${tableName} (\\r\\n`\r\n            + `\\t${obj.spec.structName}_id BIGINT UNSIGNED NOT NULL,\\r\\n`\r\n            + `\\tFOREIGN KEY (${obj.spec.structName}_id) REFERENCES ${obj.spec.structName} (id)\\r\\n`\r\n            + ");\\r\\n");\r\n    }\r\n    const type = obj.spec.type.toLowerCase();\r\n    const datatype = etcd.kindNameIndex[`datatype:${obj.spec.type.toLowerCase()}`];\r\n    if (!datatype) {\r\n        throw new Error(`Data type \'${type}\' not recognized.`);\r\n    }\r\n    let columnString = `ALTER TABLE ${obj.spec.databaseName}.${tableName}\\r\\n`\r\n        + `ADD COLUMN IF NOT EXISTS \\`${obj.spec.name}\\` `;\r\n    if (datatype.spec.values) {\r\n        const maxLengthValue = datatype.spec.values.sort((a, b) => (b.length - a.length))[0].length;\r\n        columnString += `CHAR(${maxLengthValue})`;\r\n    }\r\n    else if (datatype.spec.targets.mariadb) {\r\n        columnString += datatype.spec.targets.mariadb.nativeType;\r\n    }\r\n    else if (datatype.spec.targets.mysql) {\r\n        columnString += datatype.spec.targets.mysql.nativeType;\r\n    }\r\n    else {\r\n        throw new Error(`DataType \'${datatype.metadata.name}\' has no MariaDB or MySQL equivalent.`);\r\n    }\r\n    if (obj.spec.characterSet) {\r\n        const characterSet = etcd.kindIndex.characterset\r\n            .find((cs) => obj.spec.characterSet === cs.spec.name);\r\n        if (characterSet) {\r\n            const mariaDBEquivalent = characterSet.spec.targetEquivalents.mariadb\r\n                || characterSet.spec.targetEquivalents.mysql;\r\n            if (mariaDBEquivalent) {\r\n                columnString += ` CHARACTER SET \'${mariaDBEquivalent}\'`;\r\n            }\r\n            else {\r\n                logger.warn("No MariaDB or MySQL equivalent character set for PreQL "\r\n                    + `character set \'${characterSet.metadata.name}\'.`);\r\n            }\r\n        }\r\n        else {\r\n            logger.error(`Expected CharacterSet \'${obj.spec.characterSet}\' did not exist! `\r\n                + "This is a bug in the PreQL Core library.");\r\n        }\r\n    }\r\n    if (obj.spec.collation) {\r\n        const collation = etcd.kindIndex.collation\r\n            .find((c) => obj.spec.collation === c.spec.name);\r\n        if (collation) {\r\n            const mariaDBEquivalent = collation.spec.targetEquivalents.mariadb\r\n                || collation.spec.targetEquivalents.mysql;\r\n            if (mariaDBEquivalent) {\r\n                columnString += ` COLLATE \'${mariaDBEquivalent}\'`;\r\n            }\r\n            else {\r\n                logger.warn("No MariaDB or MySQL equivalent collation for PreQL "\r\n                    + `collation \'${collation.metadata.name}\'.`);\r\n            }\r\n        }\r\n        else {\r\n            logger.error(`Expected Collation \'${obj.spec.characterSet}\' did not exist! `\r\n                + "This is a bug in the PreQL Core library.");\r\n        }\r\n    }\r\n    if (obj.spec.nullable && (!obj.spec.multiValued))\r\n        columnString += " NULL";\r\n    else\r\n        columnString += " NOT NULL";\r\n    // Simply quoting the default value is fine, because MariaDB will cast it.\r\n    if (obj.spec.default)\r\n        columnString += ` DEFAULT \'${obj.spec.default}\'`;\r\n    if (obj.metadata.annotations && obj.metadata.annotations.comment) {\r\n        columnString += `\\r\\nCOMMENT \'${obj.metadata.annotations.comment}\'`;\r\n    }\r\n    ret.push(columnString);\r\n    if (datatype.spec.values) {\r\n        const storedProcedureName = `${obj.spec.databaseName}.add_enum_${datatype.spec.name}`;\r\n        const foreignKeyName = `enum_${obj.spec.structName}_${obj.spec.name}`;\r\n        const enumTableName = `${datatype.spec.name}_enum`;\r\n        const maxLengthValue = datatype.spec.values.sort((a, b) => (b.length - a.length))[0].length;\r\n        // Add Enum Table\r\n        ret.push(`CREATE TABLE IF NOT EXISTS ${obj.spec.databaseName}.${enumTableName} (\\r\\n`\r\n            + `\\tvalue CHAR(${maxLengthValue}) NOT NULL PRIMARY KEY\\r\\n`\r\n            + ")");\r\n        // Insert Enum Values\r\n        ret.push(`INSERT IGNORE INTO ${obj.spec.databaseName}.${enumTableName} VALUES\\r\\n`\r\n            + datatype.spec.values\r\n                .map((v, i) => `\\t/* ${obj.spec.databaseName}.${enumTableName}[${i}] */ (\'${v}\')`)\r\n                .join(",\\r\\n"));\r\n        // Add FKC\r\n        ret.push(`DROP PROCEDURE IF EXISTS ${storedProcedureName}`);\r\n        ret.push(+`CREATE PROCEDURE ${storedProcedureName} ()\\r\\n`\r\n            + "BEGIN\\r\\n"\r\n            + "\\tDECLARE EXIT HANDLER FOR 1005 DO 0;\\r\\n"\r\n            + `\\tALTER TABLE ${obj.spec.databaseName}.${obj.spec.structName}\\r\\n`\r\n            + `\\tADD CONSTRAINT ${foreignKeyName} FOREIGN KEY\\r\\n`\r\n            + `\\tIF NOT EXISTS ${foreignKeyName}_index (\\`${obj.spec.name}\\`)\\r\\n`\r\n            + `\\tREFERENCES ${enumTableName} (value);\\r\\n`\r\n            + "END");\r\n        ret.push(`CALL ${storedProcedureName}`);\r\n        ret.push(`DROP PROCEDURE IF EXISTS ${storedProcedureName}`);\r\n        return ret;\r\n    }\r\n    if (datatype.spec.regexes && datatype.spec.regexes.pcre) {\r\n        const checkRegexps = [];\r\n        const constraintBaseName = `${obj.spec.databaseName}.${tableName}.preql_${obj.spec.name}`;\r\n        // Every regex within a group must match.\r\n        Object.entries(datatype.spec.regexes.pcre).forEach((group) => {\r\n            const groupRegexps = [];\r\n            if (!(datatype.spec.regexes))\r\n                return; // Just to make TypeScript happy.\r\n            Object.entries(datatype.spec.regexes.pcre[group[0]]).forEach((re) => {\r\n                groupRegexps.push(`${obj.spec.name} ${re[1].positive ? "" : "NOT"} REGEXP \'${re[1].pattern.replace("\'", "\'\'")}\'`);\r\n            });\r\n            checkRegexps.push(`(${groupRegexps.join(" AND ")})`);\r\n        });\r\n        const qualifiedTableName = `${obj.spec.databaseName}.${tableName}`;\r\n        ret.push(`ALTER TABLE ${qualifiedTableName}\\r\\nDROP CONSTRAINT IF EXISTS ${constraintBaseName}`);\r\n        ret.push(`ALTER TABLE ${qualifiedTableName}\\r\\nADD CONSTRAINT IF NOT EXISTS ${constraintBaseName}\\r\\nCHECK (${checkRegexps.join(" OR ")})`);\r\n    }\r\n    if (datatype.spec.setters) {\r\n        const qualifiedTableName = `${obj.spec.databaseName}.${tableName}`;\r\n        let previousExpression = `NEW.${obj.spec.name}`;\r\n        const triggerBaseName = `${obj.spec.databaseName}.preql_${tableName}_${obj.spec.name}`;\r\n        datatype.spec.setters.forEach((setter) => {\r\n            // REVIEW: I had some weird issues with this, hence "as string."\r\n            switch (setter.type.toLowerCase()) {\r\n                case ("trim"): {\r\n                    previousExpression = (() => {\r\n                        if (!(setter.side))\r\n                            return `TRIM(${previousExpression})`;\r\n                        if (setter.side.toLowerCase() === "left")\r\n                            return `LTRIM(${previousExpression})`;\r\n                        if (setter.side.toLowerCase() === "right")\r\n                            return `RTRIM(${previousExpression})`;\r\n                        return `TRIM(${previousExpression})`;\r\n                    })();\r\n                    break;\r\n                }\r\n                case ("substring"): {\r\n                    if (setter.toIndex) {\r\n                        previousExpression = `SUBSTRING(${previousExpression}, ${setter.fromIndex + 1}, ${setter.toIndex + 1})`;\r\n                    }\r\n                    else {\r\n                        previousExpression = `SUBSTRING(${previousExpression}, ${setter.fromIndex + 1})`;\r\n                    }\r\n                    break;\r\n                }\r\n                case ("replace"): {\r\n                    const from = setter.from.replace("\'", "\'\'").replace("\\\\", "\\\\\\\\");\r\n                    const to = setter.to.replace("\'", "\'\'").replace("\\\\", "\\\\\\\\");\r\n                    previousExpression = `REPLACE(${previousExpression}, ${from}, ${to})`;\r\n                    break;\r\n                }\r\n                case ("case"): {\r\n                    switch (setter.casing) {\r\n                        case ("upper"):\r\n                            previousExpression = `UPPER(${previousExpression})`;\r\n                            break;\r\n                        case ("lower"):\r\n                            previousExpression = `LOWER(${previousExpression})`;\r\n                            break;\r\n                        default: {\r\n                            throw new Error(`Invalid casing: \'${setter.casing}\'.`);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case ("pad"): {\r\n                    const padString = setter.padString.replace("\'", "\'\'").replace("\\\\", "\\\\\\\\");\r\n                    switch (setter.side) {\r\n                        case ("left"): {\r\n                            previousExpression = `LPAD(${previousExpression}, ${setter.padLength}, ${padString})`;\r\n                            break;\r\n                        }\r\n                        case ("right"): {\r\n                            previousExpression = `RPAD(${previousExpression}, ${setter.padLength}, \'${padString}\')`;\r\n                            break;\r\n                        }\r\n                        default: {\r\n                            throw new Error(`Invalid side: \'${setter.side}\'.`);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case ("now"):\r\n                    previousExpression = "NOW()";\r\n                    break;\r\n                default: {\r\n                    // REVIEW: I had some weird issues with this, hence "as string."\r\n                    throw new Error(`Setter \'${setter.type.toLowerCase()}\' not understood.`);\r\n                }\r\n            }\r\n        });\r\n        ret.push(`DROP TRIGGER IF EXISTS ${triggerBaseName}_insert`);\r\n        ret.push(`BEFORE INSERT ON ${qualifiedTableName} FOR EACH ROW\\r\\nSET NEW.${obj.spec.name} = ${previousExpression}`);\r\n        ret.push(`CREATE TRIGGER IF NOT EXISTS ${triggerBaseName}_insert\\r\\n`\r\n            + `BEFORE INSERT ON ${qualifiedTableName} FOR EACH ROW\\r\\n`\r\n            + `SET NEW.${obj.spec.name} = ${previousExpression}\\r\\n`);\r\n        ret.push(`DROP TRIGGER IF EXISTS ${triggerBaseName}_update`);\r\n        ret.push(`CREATE TRIGGER IF NOT EXISTS ${triggerBaseName}_update\\r\\n`\r\n            + `BEFORE UPDATE ON ${qualifiedTableName} FOR EACH ROW\\r\\n`\r\n            + `SET NEW.${obj.spec.name} = ${previousExpression}`);\r\n    }\r\n    return ret;\r\n};\r\nexports.default = transpileAttribute;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/attribute.ts?')},"./source/Transpilers/database.ts":
/*!****************************************!*\
  !*** ./source/Transpilers/database.ts ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst transpileDatabase = async (obj, logger, etcd) => {\r\n    let ret = [\r\n        `CREATE DATABASE IF NOT EXISTS ${obj.spec.name}`,\r\n    ];\r\n    if (obj.spec.characterSet) {\r\n        const characterSet = etcd.kindIndex.characterset\r\n            .find((cs) => obj.spec.characterSet === cs.spec.name);\r\n        if (characterSet) {\r\n            const mariaDBEquivalent = characterSet.spec.targetEquivalents.mariadb\r\n                || characterSet.spec.targetEquivalents.mysql;\r\n            if (mariaDBEquivalent) {\r\n                ret.push(`ALTER DATABASE ${obj.spec.name} DEFAULT CHARACTER SET = '${mariaDBEquivalent}'`);\r\n            }\r\n            else {\r\n                logger.warn(\"No MariaDB or MySQL equivalent character set for PreQL \"\r\n                    + `character set '${characterSet.metadata.name}'.`);\r\n            }\r\n        }\r\n        else {\r\n            logger.error(`Expected CharacterSet '${obj.spec.characterSet}' did not exist! `\r\n                + \"This is a bug in the PreQL Core library.\");\r\n        }\r\n    }\r\n    if (obj.spec.collation) {\r\n        const collation = etcd.kindIndex.collation\r\n            .find((c) => obj.spec.collation === c.spec.name);\r\n        if (collation) {\r\n            const mariaDBEquivalent = collation.spec.targetEquivalents.mariadb\r\n                || collation.spec.targetEquivalents.mysql;\r\n            if (mariaDBEquivalent) {\r\n                ret.push(`ALTER DATABASE ${obj.spec.name} DEFAULT COLLATE = '${mariaDBEquivalent}'`);\r\n            }\r\n            else {\r\n                logger.warn(\"No MariaDB or MySQL equivalent collation for PreQL \"\r\n                    + `collation '${collation.metadata.name}'.`);\r\n            }\r\n        }\r\n        else {\r\n            logger.error(`Expected Collation '${obj.spec.characterSet}' did not exist! `\r\n                + \"This is a bug in the PreQL Core library.\");\r\n        }\r\n    }\r\n    return ret;\r\n};\r\nexports.default = transpileDatabase;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/database.ts?")},"./source/Transpilers/entry.ts":
/*!*************************************!*\
  !*** ./source/Transpilers/entry.ts ***!
  \*************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst transpileEntry = async (obj) => [\r\n    `INSERT INTO ${obj.spec.databaseName}.${obj.spec.structName}\\r\\n`\r\n        + "SET\\r\\n\\t"\r\n        + `id = ${obj.spec.id},\\r\\n\\t`\r\n        + Object.entries(obj.spec.values)\r\n            .map((kv) => {\r\n            const key = kv[0];\r\n            const value = kv[1];\r\n            switch (typeof key) {\r\n                case "boolean": return `${key} = ${value ? "TRUE" : "FALSE"}`;\r\n                case "number": return `${key} = ${value}`;\r\n                case "string": return `${key} = \'${value}\'`;\r\n                default: throw new Error(`Invalid data type for entry field \'${key}\'.`);\r\n            }\r\n        })\r\n            .join(",\\r\\n\\t")\r\n        + "\\r\\nON DUPLICATE KEY UPDATE\\r\\n\\t"\r\n        + Object.entries(obj.spec.values)\r\n            .map((kv) => {\r\n            const key = kv[0];\r\n            const value = kv[1];\r\n            switch (typeof key) {\r\n                case "boolean": return `${key} = ${value ? "TRUE" : "FALSE"}`;\r\n                case "number": return `${key} = ${value}`;\r\n                case "string": return `${key} = \'${value}\'`;\r\n                default: throw new Error(`Invalid data type for entry field \'${key}\'.`);\r\n            }\r\n        })\r\n            .join(",\\r\\n\\t"),\r\n];\r\nexports.default = transpileEntry;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/entry.ts?')},"./source/Transpilers/foreignkey.ts":
/*!******************************************!*\
  !*** ./source/Transpilers/foreignkey.ts ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { "default": mod };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst escape_1 = __importDefault(__webpack_require__(/*! ../escape */ "./source/escape.ts"));\r\nconst transpileForeignKeyConstraint = async (obj) => {\r\n    const storedProcedureName = `${obj.spec.databaseName}.create_fk_${obj.spec.name}`;\r\n    const foreignKeyName = `fk_${obj.spec.childStructName}_${obj.spec.parentStructName}`;\r\n    const comment = obj.metadata.labels.comment ? escape_1.default(obj.metadata.labels.comment) : "";\r\n    return [\r\n        `ALTER TABLE ${obj.spec.databaseName}.${obj.spec.childStructName}\\r\\n`\r\n            + `ADD COLUMN IF NOT EXISTS ${obj.spec.name} `\r\n            + `BIGINT UNSIGNED ${obj.spec.nullable ? "NULL" : "NOT NULL"}`\r\n            + `${comment.length ? "\\r\\nCOMMENT \'" + comment + "\'" : ""}`,\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n        `CREATE PROCEDURE ${storedProcedureName} ()\\r\\n`\r\n            + "BEGIN\\r\\n"\r\n            + "\\tDECLARE EXIT HANDLER FOR 1005 DO 0;\\r\\n"\r\n            + `\\tALTER TABLE ${obj.spec.databaseName}.${obj.spec.childStructName}\\r\\n`\r\n            + `\\tADD CONSTRAINT ${foreignKeyName} FOREIGN KEY\\r\\n`\r\n            + `\\tIF NOT EXISTS ${foreignKeyName}_index (${obj.spec.name})\\r\\n`\r\n            + `\\tREFERENCES ${obj.spec.parentStructName} (id)\\r\\n`\r\n            + `\\tON DELETE ${obj.spec.onDeleteAction.toUpperCase() || "RESTRICT"}\\r\\n`\r\n            + `\\tON UPDATE ${obj.spec.onUpdateAction.toUpperCase() || "RESTRICT"};\\r\\n`\r\n            + "END",\r\n        `CALL ${storedProcedureName}`,\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n    ];\r\n};\r\nexports.default = transpileForeignKeyConstraint;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/foreignkey.ts?')},"./source/Transpilers/plainindex.ts":
/*!******************************************!*\
  !*** ./source/Transpilers/plainindex.ts ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst transpilePlainIndex = async (obj) => {\r\n    const columnString = obj.spec.keyAttributes\r\n        .map((key) => `${key.name} ${(key.ascending ? "ASC" : "DESC")}`)\r\n        .join(", ");\r\n    return [\r\n        `ALTER TABLE ${obj.spec.databaseName}.${obj.spec.structName}\\r\\n`\r\n            + `ADD INDEX IF NOT EXISTS ${obj.spec.name} (${columnString})`,\r\n    ];\r\n};\r\nexports.default = transpilePlainIndex;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/plainindex.ts?')},"./source/Transpilers/postamble.ts":
/*!*****************************************!*\
  !*** ./source/Transpilers/postamble.ts ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { "default": mod };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst commentOut_1 = __importDefault(__webpack_require__(/*! ../commentOut */ "./source/commentOut.ts"));\r\nconst transpilePostamble = async (obj) => [commentOut_1.default(obj.spec.uncommentedText)];\r\nexports.default = transpilePostamble;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/postamble.ts?')},"./source/Transpilers/preamble.ts":
/*!****************************************!*\
  !*** ./source/Transpilers/preamble.ts ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { "default": mod };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst commentOut_1 = __importDefault(__webpack_require__(/*! ../commentOut */ "./source/commentOut.ts"));\r\nconst transpilePreamble = async (obj) => [commentOut_1.default(obj.spec.uncommentedText)];\r\nexports.default = transpilePreamble;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/preamble.ts?')},"./source/Transpilers/server.ts":
/*!**************************************!*\
  !*** ./source/Transpilers/server.ts ***!
  \**************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n// import { offsetOf, Timezone } from "tz-offset";\r\nconst transpileServer = async (obj, logger, etcd) => {\r\n    /**\r\n     * I don\'t know if IF statements count as a multiple statement or just one,\r\n     * but using the IF statement method may be undesirable anyway. For now,\r\n     * this just returns nothing. It may be wiser to conditionally configure\r\n     * the server outside of the transpiled SQL.\r\n     */\r\n    return [];\r\n};\r\nexports.default = transpileServer;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/server.ts?')},"./source/Transpilers/spatialindex.ts":
/*!********************************************!*\
  !*** ./source/Transpilers/spatialindex.ts ***!
  \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst transpileSpatialIndex = async (obj) => {\r\n    const schemaName = obj.spec.databaseName;\r\n    const tableName = obj.spec.structName;\r\n    const indexName = obj.spec.name;\r\n    const storedProcedureName = `create_index_${indexName}`;\r\n    const columnString = obj.spec.keyAttributes\r\n        .map((key) => `${key.name} ${(key.ascending ? "ASC" : "DESC")}`)\r\n        .join(", ");\r\n    return [\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n        `CREATE PROCEDURE ${storedProcedureName} ()\\r\\n`\r\n            + "BEGIN\\r\\n"\r\n            + "\\tDECLARE EXIT HANDLER FOR 1061 DO 0;\\r\\n"\r\n            + `\\tALTER TABLE ${schemaName}.${tableName}\\r\\n`\r\n            + `\\tADD SPATIAL INDEX (${columnString});\\r\\n`\r\n            + "END",\r\n        `CALL ${storedProcedureName}`,\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n    ];\r\n};\r\nexports.default = transpileSpatialIndex;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/spatialindex.ts?')},"./source/Transpilers/struct.ts":
/*!**************************************!*\
  !*** ./source/Transpilers/struct.ts ***!
  \**************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst transpileStruct = async (obj, logger, etcd) => {\r\n    const ret = [\r\n        `CREATE TABLE IF NOT EXISTS ${obj.spec.databaseName}.${obj.spec.name} `\r\n            + "(id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY)",\r\n        `ALTER TABLE ${obj.spec.databaseName}.${obj.spec.name} `\r\n            + "ADD COLUMN IF NOT EXISTS id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY",\r\n    ];\r\n    if (obj.spec.characterSet) {\r\n        const characterSet = etcd.kindNameIndex[`characterset:${obj.spec.characterSet.toLowerCase()}`];\r\n        if (characterSet) {\r\n            // TODO: Make this capitalization-proof.\r\n            const mariaDBEquivalent = characterSet.spec.targetEquivalents.mariadb\r\n                || characterSet.spec.targetEquivalents.mysql;\r\n            if (mariaDBEquivalent) {\r\n                ret.push(`ALTER TABLE ${obj.spec.databaseName}.${obj.spec.name} DEFAULT CHARACTER SET = \'${mariaDBEquivalent}\'`);\r\n            }\r\n            else {\r\n                logger.warn("No MariaDB or MySQL equivalent character set for PreQL "\r\n                    + `character set \'${characterSet.metadata.name}\'.`);\r\n            }\r\n        }\r\n        else {\r\n            logger.error(`Expected CharacterSet \'${obj.spec.characterSet}\' did not exist! `\r\n                + "This is a bug in the PreQL Core library.");\r\n        }\r\n    }\r\n    if (obj.spec.collation) {\r\n        const collation = etcd.kindNameIndex[`collation:${obj.spec.collation.toLowerCase()}`];\r\n        if (collation) {\r\n            const mariaDBEquivalent = collation.spec.targetEquivalents.mariadb\r\n                || collation.spec.targetEquivalents.mysql;\r\n            if (mariaDBEquivalent) {\r\n                ret.push(`ALTER TABLE ${obj.spec.databaseName}.${obj.spec.name} DEFAULT COLLATE = \'${mariaDBEquivalent}\'`);\r\n            }\r\n            else {\r\n                logger.warn("No MariaDB or MySQL equivalent collation for PreQL "\r\n                    + `collation \'${collation.metadata.name}\'.`);\r\n            }\r\n        }\r\n        else {\r\n            logger.error(`Expected Collation \'${obj.spec.characterSet}\' did not exist! `\r\n                + "This is a bug in the PreQL Core library.");\r\n        }\r\n    }\r\n    return ret;\r\n};\r\nexports.default = transpileStruct;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/struct.ts?')},"./source/Transpilers/textindex.ts":
/*!*****************************************!*\
  !*** ./source/Transpilers/textindex.ts ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst transpileTextIndex = async (obj) => {\r\n    const schemaName = obj.spec.databaseName;\r\n    const tableName = obj.spec.structName;\r\n    const indexName = obj.spec.name;\r\n    const storedProcedureName = `create_index_${indexName}`;\r\n    const columnString = obj.spec.keyAttributes\r\n        .map((key) => `${key.name} ${(key.ascending ? "ASC" : "DESC")}`)\r\n        .join(", ");\r\n    return [\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n        `CREATE PROCEDURE ${storedProcedureName} ()\\r\\n`\r\n            + "BEGIN\\r\\n"\r\n            + "\\tDECLARE EXIT HANDLER FOR 1061 DO 0;\\r\\n"\r\n            + `\\tALTER TABLE ${schemaName}.${tableName}\\r\\n`\r\n            + `\\tADD FULLTEXT INDEX (${columnString});\\r\\n`\r\n            + "END",\r\n        `CALL ${storedProcedureName}`,\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n    ];\r\n};\r\nexports.default = transpileTextIndex;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/textindex.ts?')},"./source/Transpilers/uniqueindex.ts":
/*!*******************************************!*\
  !*** ./source/Transpilers/uniqueindex.ts ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nconst transpileUniqueIndex = async (obj) => {\r\n    const schemaName = obj.spec.databaseName;\r\n    const tableName = obj.spec.structName;\r\n    const indexName = obj.spec.name;\r\n    const storedProcedureName = `create_index_${indexName}`;\r\n    const columnString = obj.spec.keyAttributes\r\n        .map((key) => `${key.name} ${(key.ascending ? "ASC" : "DESC")}`)\r\n        .join(", ");\r\n    return [\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n        `CREATE PROCEDURE ${storedProcedureName} ()\\r\\n`\r\n            + "BEGIN\\r\\n"\r\n            + "\\tDECLARE EXIT HANDLER FOR 1061 DO 0;\\r\\n"\r\n            + `\\tALTER TABLE ${schemaName}.${tableName}\\r\\n`\r\n            + `\\tADD CONSTRAINT ${indexName} UNIQUE KEY (${columnString});\\r\\n`\r\n            + "END",\r\n        `CALL ${storedProcedureName}`,\r\n        `DROP PROCEDURE IF EXISTS ${storedProcedureName}`,\r\n    ];\r\n};\r\nexports.default = transpileUniqueIndex;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/Transpilers/uniqueindex.ts?')},"./source/commentOut.ts":
/*!******************************!*\
  !*** ./source/commentOut.ts ***!
  \******************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nfunction commentOut(uncommentedText) {\r\n    return ("-- " + uncommentedText.replace(/--/gu, "\\\\-\\\\-").replace(/\\r?\\n/gu, "\\r\\n-- "));\r\n}\r\nexports.default = commentOut;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/commentOut.ts?')},"./source/escape.ts":
/*!**************************!*\
  !*** ./source/escape.ts ***!
  \**************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nfunction escape(str) {\r\n    return str\r\n        .replace("\'", "\'\'")\r\n        .replace("\\\\", "\\\\\\\\");\r\n}\r\nexports.default = escape;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/escape.ts?')},"./source/index.ts":
/*!*************************!*\
  !*** ./source/index.ts ***!
  \*************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar commentOut_1 = __webpack_require__(/*! ./commentOut */ "./source/commentOut.ts");\r\nexports.commentOut = commentOut_1.default;\r\nvar escape_1 = __webpack_require__(/*! ./escape */ "./source/escape.ts");\r\nexports.escape = escape_1.default;\r\nvar ConsoleLogger_1 = __webpack_require__(/*! ./ConsoleLogger */ "./source/ConsoleLogger.ts");\r\nexports.ConsoleLogger = ConsoleLogger_1.default;\r\nvar transpile_1 = __webpack_require__(/*! ./Commands/transpile */ "./source/Commands/transpile.ts");\r\nexports.transpile = transpile_1.default;\r\n\n\n//# sourceURL=webpack://preqlmariadb/./source/index.ts?')},0:
/*!*******************************!*\
  !*** multi ./source/index.ts ***!
  \*******************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./source/index.ts */"./source/index.ts");\n\n\n//# sourceURL=webpack://preqlmariadb/multi_./source/index.ts?')}});